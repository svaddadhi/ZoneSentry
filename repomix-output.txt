This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-03-27T19:59:18.790Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
app/
  config.py
  DESIGN.md
  email_utils.py
  main.py
  poller.py
tests/
  test_edge_cases.py
  test_geospatial.py
.env.example
.gitignore
README.md
requirements.txt
run_tests.py

================================================================
Repository Files
================================================================

================
File: app/config.py
================
import os
from dotenv import load_dotenv

# Load environment variables from .env file if it exists
load_dotenv()

# API and Clinician Info
API_BASE_URL = os.getenv("API_BASE_URL", "https://3qbqr98twd.execute-api.us-west-2.amazonaws.com/test")
CLINICIAN_IDS = [int(id) for id in os.getenv("CLINICIAN_IDS", "1,2,3,4,5,6").split(",")]

# Polling Settings
POLL_INTERVAL = int(os.getenv("POLL_INTERVAL", "120"))  # Poll every 2 minutes

# SMTP Email Settings
SMTP_HOST = os.getenv("SMTP_HOST", "smtp.gmail.com")
SMTP_PORT = int(os.getenv("SMTP_PORT", "587"))
SMTP_USER = os.getenv("SMTP_USER", "")
SMTP_PASS = os.getenv("SMTP_PASS", "")
ALERT_EMAIL_FROM = os.getenv("ALERT_EMAIL_FROM", "")
ALERT_EMAIL_TO = os.getenv("ALERT_EMAIL_TO", "")

================
File: app/DESIGN.md
================
# ZoneSentry: Detailed Design Document

## Overview

ZoneSentry is a monitoring service that polls a Clinician Status API for a set of clinician IDs. It checks if any clinician is outside their designated safety zone as defined by GeoJSON polygons. If a clinician is detected outside their zone, the service sends an email alert within 5 minutes.

---

## Requirements Recap

1. **Polling**: Query each clinician's location regularly to detect when someone leaves their designated zone, with alerts sent within 5 minutes.
2. **Alerting**: Send email alerts when a clinician is out of range (with points on the boundary also considered out-of-range).
3. **API Limits**: Stay well below 100 queries per second to avoid overloading the API.
4. **Handling Failures**: Ignore endpoint failures or non-200 responses.
5. **Simplicity**: Use straightforward logging and focused functionality.

---

## Technology Choices and Tradeoffs

### Python vs. Node.js

**Python** was chosen because it has excellent geospatial libraries (`shapely` for polygon operations) and built-in `smtplib` for sending emails. Node.js would also have worked, but Python's ecosystem for location-based checks provides more mature and well-documented options for geospatial operations.

### FastAPI vs. a Simple Cron Script

- With **FastAPI**, we can run a background task in the same application that also has a `/health` endpoint for easy monitoring.
- A **cron job** plus a plain script would be simpler if we didn't need an endpoint at all. However, having that small endpoint is helpful for confirming the service is running and for future expansion.
- FastAPI's `lifespan` context manager provides clean startup/shutdown hooks that simplify the application lifecycle.

### Shapely vs. Other Geospatial Libraries

- **Shapely** was chosen for polygon operations as it provides precise point-in-polygon checks.
- Alternatives like **GeoPy** are better for distance calculations but lack robust polygon support.
- **PyGEOS** would offer better performance but with more complexity and dependencies.
- The implementation with Shapely correctly handles complex zone boundaries, including concave polygons and multi-polygons.
- Points on the boundary are properly treated as outside the zone per requirements.

### Email Approach

- **Standard SMTP** via `smtplib` is used for simplicity and reliability.
- Alternative services like **SendGrid**, **Mailgun**, or **AWS SES** would offer better deliverability and analytics, but require additional setup and dependencies.
- The current implementation keeps things straightforward while still providing reliable email alerts.
- Email alerts include clinician ID and a clear message about zone departure.

### Deployment Options

1. **Local / VM**: The service can run with `uvicorn app.main:app` on a small VPS or local machine.
2. **Docker**: The service could be containerized for deployment to container platforms.
3. **Serverless**: For a fully managed approach, the service could be adapted to run as cloud functions.

---

## Design and Architecture

1. **FastAPI Application**

   - `main.py` sets up a FastAPI instance with a startup hook that launches the async background task.
   - A `/health` route provides basic service status.

2. **Background Polling**

   - The polling loop runs every 2 minutes (configurable).
   - It calls `GET /clinicianstatus/{id}` for each ID in the configured list.
   - For each 200 OK response, it parses GeoJSON to extract:
     - The clinician's current position as a point
     - The safety zone boundaries as polygons
   - If the point is outside all polygons, an email alert is sent.
   - Failed API calls are ignored per requirements.

3. **GeoJSON Processing**

   - The `extract_geometries()` function extracts both points and polygons from GeoJSON.
   - The `is_out_of_zone()` function checks if a point is outside all polygons.
   - Boundary points are correctly treated as outside the zone.

4. **Alerting**

   - When a clinician is detected outside their zone, an email is sent via SMTP.
   - Error handling ensures the service continues operating even if email sending fails.

5. **Logging**
   - Structured logging is implemented throughout the application.
   - Log entries include timestamps and relevant context (clinician IDs, status, etc.)

---

## Testing Approach

1. **Unit Tests**

   - Comprehensive test suite for the core geospatial functions.
   - Tests cover standard cases, edge cases, and parsing of real API responses.
   - Edge cases include concave polygons, points on boundaries, and complex shapes.

2. **Manual Testing**

   - Testing with real API data confirms the accuracy of the zone detection logic.
   - Email delivery can be tested by pointing alerts to a personal address first.

3. **Deployment Testing**
   - For the official submission, the service is run continuously for an hour.
   - Email alerts are directed to the official submission address.

---

## Future Enhancements

1. **Alert De-duplication**: Add a cache mechanism to prevent repeated alerts for the same out-of-zone clinician.

2. **More Robust Email Delivery**: Integrate with a transactional email service for better delivery reliability.

3. **Enhanced Monitoring**: Add metrics collection and dashboards for service health and alert patterns.

4. **Advanced Geo-fencing**: Add support for time-based restrictions or dynamic safety zones.

---

## Conclusion

ZoneSentry is a reliable monitoring service that periodically checks clinician locations against their designated safety zones. It meets all requirements by accurately detecting zone departures and sending timely alerts without overloading the API. The application architecture is modular and well-tested, making it easy to maintain and extend.

================
File: app/email_utils.py
================
import logging
import smtplib
from email.mime.text import MIMEText
from .config import (
    SMTP_HOST, SMTP_PORT, SMTP_USER, SMTP_PASS,
    ALERT_EMAIL_FROM, ALERT_EMAIL_TO
)

logger = logging.getLogger(__name__)

def send_alert_email(clinician_id: int):
    subject = f"Clinician {clinician_id} Out of Zone"
    body = f"Clinician with ID {clinician_id} is out of the expected zone."
    msg = MIMEText(body)
    msg["Subject"] = subject
    msg["From"] = ALERT_EMAIL_FROM
    msg["To"] = ALERT_EMAIL_TO

    try:
        with smtplib.SMTP(SMTP_HOST, SMTP_PORT) as server:
            server.starttls()
            server.login(SMTP_USER, SMTP_PASS)
            server.send_message(msg)
        logger.info(f"Alert email sent for clinician {clinician_id}")
    except Exception as e:
        logger.error(f"Error sending email for clinician {clinician_id}: {e}")

================
File: app/main.py
================
import asyncio
import logging
from contextlib import asynccontextmanager
from fastapi import FastAPI

from .poller import check_clinicians_periodically

# Configure global logging with timestamps (ISO-ish date) and log level
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s [%(levelname)s] %(name)s: %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S'
)

@asynccontextmanager
async def lifespan(app: FastAPI):
    logging.info("Starting up the ZoneSentry service...")
    task = asyncio.create_task(check_clinicians_periodically())
    yield
    task.cancel()

# Create FastAPI app
app = FastAPI(lifespan=lifespan)

@app.get("/health")
def health_check():
    return {"status": "ok"}

================
File: app/poller.py
================
import requests
import asyncio
import logging
from shapely.geometry import Point, Polygon

from .config import (
    API_BASE_URL, CLINICIAN_IDS, POLL_INTERVAL
)
from .email_utils import send_alert_email

logger = logging.getLogger(__name__)

async def check_clinicians_periodically():
    logger.info("Polling task started.")
    while True:
        logger.info("Beginning a new polling cycle...")
        for clinician_id in CLINICIAN_IDS:
            try:
                resp = requests.get(f"{API_BASE_URL}/clinicianstatus/{clinician_id}", timeout=5)
                if resp.status_code == 200:
                    data = resp.json()
                    # Extract point and polygon geometries
                    point, polygons = extract_geometries(data)
                    
                    if point and polygons:
                        if is_out_of_zone(point, polygons):
                            logger.info(f"Clinician {clinician_id} is outside their zone - sending alert!")
                            send_alert_email(clinician_id)
                        else:
                            logger.info(f"Clinician {clinician_id} is within their zone.")
                    else:
                        logger.warning(f"Missing either point or polygons for clinician {clinician_id}. Ignoring.")
                else:
                    logger.warning(f"Clinician {clinician_id} => HTTP {resp.status_code}. Ignoring.")
            except Exception as e:
                logger.error(f"Request/parse failed for clinician {clinician_id}: {e}")

        logger.info(f"Sleeping {POLL_INTERVAL} seconds until next polling cycle...")
        await asyncio.sleep(POLL_INTERVAL)

def extract_geometries(feature_collection: dict):
    """
    Extract both point and polygons from the GeoJSON response.
    Returns (point, polygons) where:
    - point is a shapely Point
    - polygons is a list of shapely Polygon objects
    """
    point = None
    polygons = []
    
    features = feature_collection.get("features", [])
    for feature in features:
        geom = feature.get("geometry", {})
        geom_type = geom.get("type")
        
        if geom_type == "Point":
            coords = geom.get("coordinates")  # [lon, lat]
            if coords and len(coords) >= 2:
                # Shapely uses (x, y) which maps to (lon, lat) in geo
                point = Point(coords)
        
        elif geom_type == "Polygon":
            coords_rings = geom.get("coordinates", [])
            if coords_rings and len(coords_rings) > 0:
                for ring in coords_rings:
                    # Create polygon - no need to swap coords, shapely expects (lon, lat)
                    polygon = Polygon(ring)
                    polygons.append(polygon)
    
    return point, polygons

def is_out_of_zone(point: Point, polygons: list) -> bool:
    """
    Check if a point is outside ALL of the given polygons.
    Returns True if the point is outside all polygons.
    """
    if not polygons:
        return True
    
    # A clinician is in the zone if they're inside ANY of the polygons
    for polygon in polygons:
        # Check if the point is within or on boundary of the polygon
        # Strict "within" excludes the boundary, so we use "contains" instead
        if polygon.contains(point):
            return False
    
    # If we get here, the point is outside all polygons
    return True

================
File: tests/test_edge_cases.py
================
import unittest
from unittest.mock import patch, MagicMock
from app.poller import extract_geometries, is_out_of_zone
from shapely.geometry import Point, Polygon

class TestEdgeCases(unittest.TestCase):
    def test_point_exactly_on_vertex(self):
        # Test with point exactly on a polygon vertex
        point = Point(-122.36, 37.58)
        polygon = Polygon([
            (-122.36, 37.58),  # Point is on this vertex
            (-122.35, 37.58),
            (-122.35, 37.59),
            (-122.36, 37.59),
            (-122.36, 37.58)
        ])
        
        # Points on boundary should be considered outside per spec
        self.assertTrue(is_out_of_zone(point, [polygon]))
    
    def test_concave_polygon(self):
        # Test with concave polygon (complex shape)
        point_inside = Point(-122.368, 37.585)  # Adjusted to be clearly inside
        point_in_concave = Point(-122.363, 37.583)
        
        # Create a concave polygon (C shape)
        concave_polygon = Polygon([
            (-122.37, 37.58),
            (-122.36, 37.58),
            (-122.36, 37.582),
            (-122.365, 37.582),
            (-122.365, 37.588),
            (-122.36, 37.588),
            (-122.36, 37.59),
            (-122.37, 37.59),
            (-122.37, 37.58)
        ])
        
        self.assertFalse(is_out_of_zone(point_inside, [concave_polygon]))
        
        self.assertTrue(is_out_of_zone(point_in_concave, [concave_polygon]))
    
    def test_polygon_with_hole(self):
        # Test with polygon that has a hole in it
        outer_ring = [
            (-122.37, 37.58),
            (-122.36, 37.58),
            (-122.36, 37.59),
            (-122.37, 37.59),
            (-122.37, 37.58)
        ]
        
        # This simulates how Shapely would handle a hole
        # In GeoJSON, holes would be separate rings in the coordinates array
        polygon_with_hole = Polygon(
            outer_ring,
            [[  # Inner ring (hole)
                (-122.365, 37.585),
                (-122.365, 37.582),
                (-122.362, 37.582),
                (-122.362, 37.585),
                (-122.365, 37.585)
            ]]
        )
        
        point_in_main = Point(-122.368, 37.585)  # In main polygon
        point_in_hole = Point(-122.363, 37.583)  # In the hole
        
        # Point in the main area of polygon
        self.assertFalse(is_out_of_zone(point_in_main, [polygon_with_hole]))
        
        # Point in the hole should be considered outside
        self.assertTrue(is_out_of_zone(point_in_hole, [polygon_with_hole]))
    
    def test_self_intersecting_polygon(self):
        # Test with self-intersecting polygon (figure 8 shape)
        figure8_polygon = Polygon([
            (-122.37, 37.58),
            (-122.36, 37.59),
            (-122.35, 37.58),
            (-122.36, 37.57),
            (-122.37, 37.58)
        ])
        
        point = Point(-122.36, 37.58)
        
        # Point in center of figure 8 - behavior depends on shapely's handling
        # of self-intersecting polygons, but we just need to ensure it doesn't crash
        result = is_out_of_zone(point, [figure8_polygon])
        # We don't assert specific result because self-intersecting polygons can be handled differently
        
    def test_precision_issues(self):
        # Test with very close points that could have floating point precision issues
        polygon = Polygon([
            (-122.36000000000001, 37.58),
            (-122.35, 37.58),
            (-122.35, 37.59),
            (-122.36, 37.59),
            (-122.36000000000001, 37.58)
        ])
        
        # Point just barely inside
        point_just_inside = Point(-122.359999, 37.58001)
        
        # Point just barely outside
        point_just_outside = Point(-122.360001, 37.57999)
        
        # Verify proper classification
        self.assertFalse(is_out_of_zone(point_just_inside, [polygon]))
        self.assertTrue(is_out_of_zone(point_just_outside, [polygon]))
    
    @patch('app.poller.extract_geometries')
    def test_missing_point_or_polygon(self, mock_extract):
        # Test handling when extraction returns None for point or empty list for polygons
        mock_extract.return_value = (None, [Polygon([(0,0), (1,0), (1,1), (0,1)])])
        # Should handle this gracefully without errors
        
        mock_extract.return_value = (Point(0,0), [])
        # Should handle this gracefully without errors

if __name__ == '__main__':
    unittest.main()

================
File: tests/test_geospatial.py
================
import unittest
from shapely.geometry import Point, Polygon
from app.poller import extract_geometries, is_out_of_zone

class TestGeospatialFunctions(unittest.TestCase):
    def test_extract_point_and_polygon(self):
        # Test a standard response with point and polygon
        geojson = {
            "type": "FeatureCollection",
            "features": [
                {
                    "type": "Feature",
                    "properties": {},
                    "geometry": {
                        "type": "Point",
                        "coordinates": [-122.3680236578, 37.5871044834]
                    }
                },
                {
                    "type": "Feature",
                    "properties": {},
                    "geometry": {
                        "type": "Polygon",
                        "coordinates": [[
                            [-122.36, 37.58],
                            [-122.35, 37.58],
                            [-122.35, 37.59],
                            [-122.36, 37.59],
                            [-122.36, 37.58]
                        ]]
                    }
                }
            ]
        }
        
        point, polygons = extract_geometries(geojson)
        self.assertIsNotNone(point)
        self.assertEqual(len(polygons), 1)
        self.assertEqual(point.x, -122.3680236578)
        self.assertEqual(point.y, 37.5871044834)
    
    def test_extract_with_multiple_polygons(self):
        # Test response with point and multiple polygons
        geojson = {
            "type": "FeatureCollection",
            "features": [
                {
                    "type": "Feature",
                    "properties": {},
                    "geometry": {
                        "type": "Point",
                        "coordinates": [-122.28, 37.51]
                    }
                },
                {
                    "type": "Feature",
                    "properties": {},
                    "geometry": {
                        "type": "Polygon",
                        "coordinates": [[
                            [-122.30, 37.54],
                            [-122.31, 37.53],
                            [-122.29, 37.53],
                            [-122.30, 37.54]
                        ]]
                    }
                },
                {
                    "type": "Feature",
                    "properties": {},
                    "geometry": {
                        "type": "Polygon",
                        "coordinates": [[
                            [-122.28, 37.52],
                            [-122.29, 37.51],
                            [-122.28, 37.51],
                            [-122.28, 37.52]
                        ]]
                    }
                }
            ]
        }
        
        point, polygons = extract_geometries(geojson)
        self.assertIsNotNone(point)
        self.assertEqual(len(polygons), 2)
    
    def test_extract_with_missing_point(self):
        # Test response with missing point
        geojson = {
            "type": "FeatureCollection",
            "features": [
                {
                    "type": "Feature",
                    "properties": {},
                    "geometry": {
                        "type": "Polygon",
                        "coordinates": [[
                            [-122.36, 37.58],
                            [-122.35, 37.58],
                            [-122.35, 37.59],
                            [-122.36, 37.59],
                            [-122.36, 37.58]
                        ]]
                    }
                }
            ]
        }
        
        point, polygons = extract_geometries(geojson)
        self.assertIsNone(point)
        self.assertEqual(len(polygons), 1)
    
    def test_extract_with_missing_polygon(self):
        # Test response with missing polygon
        geojson = {
            "type": "FeatureCollection",
            "features": [
                {
                    "type": "Feature",
                    "properties": {},
                    "geometry": {
                        "type": "Point",
                        "coordinates": [-122.36, 37.58]
                    }
                }
            ]
        }
        
        point, polygons = extract_geometries(geojson)
        self.assertIsNotNone(point)
        self.assertEqual(len(polygons), 0)
    
    def test_empty_geojson(self):
        # Test with empty GeoJSON
        geojson = {"type": "FeatureCollection", "features": []}
        point, polygons = extract_geometries(geojson)
        self.assertIsNone(point)
        self.assertEqual(len(polygons), 0)
    
    def test_malformed_geojson(self):
        # Test with malformed GeoJSON
        geojson = {"type": "FeatureCollection"}  # Missing features
        point, polygons = extract_geometries(geojson)
        self.assertIsNone(point)
        self.assertEqual(len(polygons), 0)
    
    def test_point_inside_polygon(self):
        # Test point inside polygon
        point = Point(-122.355, 37.585)
        polygon = Polygon([
            (-122.36, 37.58),
            (-122.35, 37.58),
            (-122.35, 37.59),
            (-122.36, 37.59),
            (-122.36, 37.58)
        ])
        
        self.assertFalse(is_out_of_zone(point, [polygon]))
    
    def test_point_outside_polygon(self):
        # Test point outside polygon
        point = Point(-122.37, 37.59)
        polygon = Polygon([
            (-122.36, 37.58),
            (-122.35, 37.58),
            (-122.35, 37.59),
            (-122.36, 37.59),
            (-122.36, 37.58)
        ])
        
        self.assertTrue(is_out_of_zone(point, [polygon]))
    
    def test_point_on_polygon_boundary(self):
        # Test point on polygon boundary
        point = Point(-122.36, 37.585)
        polygon = Polygon([
            (-122.36, 37.58),
            (-122.35, 37.58),
            (-122.35, 37.59),
            (-122.36, 37.59),
            (-122.36, 37.58)
        ])
        
        # Since we're using contains(), points on boundary are considered outside
        self.assertTrue(is_out_of_zone(point, [polygon]))
    
    def test_point_inside_one_of_multiple_polygons(self):
        # Test point inside one of multiple polygons
        point = Point(-122.285, 37.515)
        polygon1 = Polygon([
            (-122.30, 37.54),
            (-122.31, 37.53),
            (-122.29, 37.53),
            (-122.30, 37.54)
        ])
        polygon2 = Polygon([
            (-122.29, 37.52),
            (-122.28, 37.51),
            (-122.27, 37.52),
            (-122.29, 37.52)
        ])
        
        self.assertFalse(is_out_of_zone(point, [polygon1, polygon2]))
    
    def test_point_outside_all_polygons(self):
        # Test point outside all polygons
        point = Point(-122.37, 37.59)
        polygon1 = Polygon([
            (-122.36, 37.58),
            (-122.35, 37.58),
            (-122.35, 37.59),
            (-122.36, 37.59),
            (-122.36, 37.58)
        ])
        polygon2 = Polygon([
            (-122.34, 37.57),
            (-122.33, 37.57),
            (-122.33, 37.58),
            (-122.34, 37.58),
            (-122.34, 37.57)
        ])
        
        self.assertTrue(is_out_of_zone(point, [polygon1, polygon2]))
    
    def test_no_polygons(self):
        # Test with no polygons
        point = Point(-122.36, 37.58)
        self.assertTrue(is_out_of_zone(point, []))

if __name__ == '__main__':
    unittest.main()

================
File: .env.example
================
# API Settings
API_BASE_URL="https://3qbqr98twd.execute-api.us-west-2.amazonaws.com/test"

# Polling Settings
POLL_INTERVAL=120

# SMTP Email Settings
SMTP_HOST="smtp.gmail.com"
SMTP_PORT=587
SMTP_USER="your-email@gmail.com"
SMTP_PASS="your-app-password"
ALERT_EMAIL_FROM="your-email@gmail.com"
ALERT_EMAIL_TO="coding-challenges+clin-alerts@sprinterhealth.com"

================
File: .gitignore
================
venv/
__pycache__/
*.py[cod]
*$py.class
.env
.DS_Store

================
File: README.md
================
# ZoneSentry

A monitoring service that tracks clinicians' locations and sends alerts when they leave their designated safety zones.

## Setup

1. Clone this repository
2. Create a virtual environment:
   ```
   python -m venv venv
   source venv/bin/activate  # On Windows: venv\Scripts\activate
   ```
3. Install dependencies:
   ```
   pip install -r requirements.txt
   ```
4. Create a `.env` file based on `.env.example`:
   ```
   cp .env.example .env
   ```
5. Update the `.env` file with your SMTP credentials and other settings

## Running the Service

Start the service using Uvicorn:

```
uvicorn app.main:app --host 0.0.0.0 --port 8000
```

The service will:

- Poll the Clinician Status API every 2 minutes (configurable)
- Check if clinicians are outside their safety zones
- Send email alerts when clinicians leave their zones

## Testing

Run the test suite:

```
python run_tests.py
```

## Design

See [DESIGN.md](app/DESIGN.md) for details on the architecture and design decisions.

================
File: requirements.txt
================
annotated-types==0.7.0
anyio==4.9.0
certifi==2025.1.31
charset-normalizer==3.4.1
click==8.1.8
exceptiongroup==1.2.2
fastapi==0.115.12
geographiclib==2.0
h11==0.14.0
idna==3.10
pydantic==2.10.6
pydantic_core==2.27.2
python-dotenv==1.0.0
requests==2.32.3
shapely==2.0.2
sniffio==1.3.1
starlette==0.46.1
typing_extensions==4.13.0
urllib3==2.3.0
uvicorn==0.34.0

================
File: run_tests.py
================
import unittest
import sys
import os

sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

def create_test_suite():
    test_loader = unittest.TestLoader()
    test_suite = unittest.TestSuite()
    
    test_dir = os.path.join(os.path.dirname(__file__), 'tests')
    test_suite.addTests(test_loader.discover(test_dir, pattern='test_*.py'))
    
    return test_suite

if __name__ == '__main__':
    test_suite = create_test_suite()
    test_runner = unittest.TextTestRunner(verbosity=2)
    result = test_runner.run(test_suite)
    
    # Return non-zero exit code if tests failed
    sys.exit(not result.wasSuccessful())
